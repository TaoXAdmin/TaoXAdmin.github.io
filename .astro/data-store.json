[["Map",1,2,7,8],"meta::meta",["Map",3,4,5,6],"astro-version","5.13.5","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://alexis-fiska.github.io\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"prism\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false}}","blog",["Map",9,10,43,44],"dompter-playwright",{"id":9,"data":11,"body":16,"filePath":17,"digest":18,"rendered":19,"legacyId":42},{"title":12,"description":13,"locale":14,"slug":9,"date":15},"Dompter Playwright : structure de test robuste en 5 étapes","Apprenez à concevoir une architecture de tests E2E maintenable avec Playwright et SpecFlow en suivant ces cinq étapes clés.","fr",["Date","2025-01-15T00:00:00.000Z"],"Playwright est devenu l’un des outils incontournables pour l’automatisation des tests end‑to‑end. Sa\nsyntaxe moderne et sa prise en charge multi‑navigateurs en font un allié de choix. Pourtant, sans\nstructure rigoureuse, une suite de tests peut vite devenir un labyrinthe fragile et lent à exécuter.\nDans cet article, je vous propose une approche en cinq étapes pour bâtir une architecture robuste,\nfacilement maintenable et intégrable à votre pipeline d’intégration continue.\n\n## 1. Choisir la bonne architecture\n\nAvant même d’écrire la première ligne de code, il est essentiel de définir une architecture de test\nclaire. La séparation des responsabilités est la clé : les **objets de page** (Page Objects)\nencapsulent les interactions avec l’interface, tandis que les étapes de test décrivent le parcours\nfonctionnel. Cette organisation permet de réutiliser le même composant pour plusieurs scénarios.\n\n```ts\n// Exemple simple d’objet de page pour la page de connexion\nexport class LoginPage {\n  constructor(private page: Page) {}\n  async goto() {\n    await this.page.goto('/login');\n  }\n  async login(username: string, password: string) {\n    await this.page.fill('input[name=\"user\"]', username);\n    await this.page.fill('input[name=\"pass\"]', password);\n    await this.page.click('button[type=\"submit\"]');\n  }\n}\n```\n\nEn BDD, ces objets de page sont appelés depuis des définitions de pas (steps) écrites en Gherkin.\nL’architecture doit rester simple : un dossier `pages` pour les pages, un dossier `steps` pour les\ndéfinitions et un dossier `tests` pour les scénarios.\n\n## 2. Adopter un cadre BDD\n\nLa seconde étape consiste à adopter un **cadre comportemental** tel que SpecFlow ou Cucumber. Le\nGherkin permet de décrire des comportements métiers compréhensibles par toutes les parties\nprenantes. Voici un exemple :\n\n```gherkin\nFonctionnalité: Authentification\n  Afin de me connecter à mon compte\n  En tant qu’utilisateur enregistré\n  Je veux saisir mes identifiants et accéder à mon tableau de bord\n\n  Scénario: Connexion valide\n    Étant donné que je suis sur la page de connexion\n    Quand je saisis mon login et mon mot de passe valides\n    Alors je suis redirigé vers mon tableau de bord\n```\n\nL’utilisation de BDD clarifie l’intention de vos tests et facilite leur revue. Les définitions de pas\ndoivent rester concises et déléguer les interactions aux objets de page.\n\n## 3. Modulariser et factoriser les composants\n\nAvec la croissance de votre suite, la tentation est grande de dupliquer du code. Au contraire,\nregroupez les interactions récurrentes dans des **helpers** et centralisez la configuration.\nOrganisez votre dépôt avec soin : un fichier `playwright.config.ts` unique, un dossier `fixtures`\npour les données de test et un utilitaire pour l’injection des dépendances. Votre productivité\ns’en trouvera décuplée.\n\n```\n// Exemple de configuration Playwright réutilisable\nexport default defineConfig({\n  use: {\n    headless: true,\n    viewport: { width: 1280, height: 720 },\n    actionTimeout: 10_000,\n    trace: 'retain-on-failure',\n  },\n});\n```\n\n## 4. Intégrer CI/CD et paralléliser\n\nUne suite de tests n’a de valeur que si elle s’exécute régulièrement. Intégrez Playwright à votre\npipeline CI/CD (GitHub Actions, GitLab CI ou Azure DevOps) et profitez de la **parallélisation**.\nDécoupez les suites en **shards** pour répartir les tests sur plusieurs agents. Utilisez les\nannotations de saut (skip) pour isoler les scénarios instables et un rapporteur de flakiness pour\nles corriger.\n\nDans GitHub Actions, une configuration simple peut lancer les tests sur deux containers :\n\n```yaml\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        shard: [1, 2]\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 18\n      - run: npm ci\n      - run: npx playwright install\n      - run: npx playwright test --shard=${{ matrix.shard }}/2\n```\n\n## 5. Maintenir et chasser les flakies\n\nEnfin, une suite robuste demande un **entretien régulier**. Mettez en place des revues de tests,\nsurveillez les temps de réponse et identifiez les tests flakies. Des outils comme [**Playwright\nTrace Viewer**](https://playwright.dev/docs/trace-viewer) et des dashboards Grafana aident à\ninvestiguer. En complément, introduisez des scripts de génération de données via des modèles\ngénératifs pour varier vos jeux de tests.\n\n![Schéma d’architecture de test](/images/placeholder_light_gray_block.png)\n\nEn suivant ces cinq étapes, vous poserez des fondations solides pour vos tests E2E. Une bonne\narchitecture se construit dans la durée : commencez petit, mesurez, itérez et impliquez vos équipes.\n\nVous souhaitez aller plus loin ? N’hésitez pas à me contacter pour un audit personnalisé ou une\nsession de coaching.","src/content/blog/dompter-playwright.fr.md","7108bb94c6bf7c6a",{"html":20,"metadata":21},"\u003Cp>Playwright est devenu l’un des outils incontournables pour l’automatisation des tests end‑to‑end. Sa\nsyntaxe moderne et sa prise en charge multi‑navigateurs en font un allié de choix. Pourtant, sans\nstructure rigoureuse, une suite de tests peut vite devenir un labyrinthe fragile et lent à exécuter.\nDans cet article, je vous propose une approche en cinq étapes pour bâtir une architecture robuste,\nfacilement maintenable et intégrable à votre pipeline d’intégration continue.\u003C/p>\n\u003Ch2 id=\"1-choisir-la-bonne-architecture\">1. Choisir la bonne architecture\u003C/h2>\n\u003Cp>Avant même d’écrire la première ligne de code, il est essentiel de définir une architecture de test\nclaire. La séparation des responsabilités est la clé : les \u003Cstrong>objets de page\u003C/strong> (Page Objects)\nencapsulent les interactions avec l’interface, tandis que les étapes de test décrivent le parcours\nfonctionnel. Cette organisation permet de réutiliser le même composant pour plusieurs scénarios.\u003C/p>\n\u003Cpre class=\"language-ts\" data-language=\"ts\">\u003Ccode is:raw=\"\" class=\"language-ts\">\u003Cspan class=\"token comment\">// Exemple simple d’objet de page pour la page de connexion\u003C/span>\n\u003Cspan class=\"token keyword\">export\u003C/span> \u003Cspan class=\"token keyword\">class\u003C/span> \u003Cspan class=\"token class-name\">LoginPage\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\n  \u003Cspan class=\"token function\">constructor\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token keyword\">private\u003C/span> page\u003Cspan class=\"token operator\">:\u003C/span> Page\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\u003Cspan class=\"token punctuation\">}\u003C/span>\n  \u003Cspan class=\"token keyword\">async\u003C/span> \u003Cspan class=\"token function\">goto\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\n    \u003Cspan class=\"token keyword\">await\u003C/span> \u003Cspan class=\"token keyword\">this\u003C/span>\u003Cspan class=\"token punctuation\">.\u003C/span>page\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">goto\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">'/login'\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token punctuation\">}\u003C/span>\n  \u003Cspan class=\"token keyword\">async\u003C/span> \u003Cspan class=\"token function\">login\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>username\u003Cspan class=\"token operator\">:\u003C/span> \u003Cspan class=\"token builtin\">string\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> password\u003Cspan class=\"token operator\">:\u003C/span> \u003Cspan class=\"token builtin\">string\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token punctuation\">{\u003C/span>\n    \u003Cspan class=\"token keyword\">await\u003C/span> \u003Cspan class=\"token keyword\">this\u003C/span>\u003Cspan class=\"token punctuation\">.\u003C/span>page\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">fill\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">'input[name=\"user\"]'\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> username\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n    \u003Cspan class=\"token keyword\">await\u003C/span> \u003Cspan class=\"token keyword\">this\u003C/span>\u003Cspan class=\"token punctuation\">.\u003C/span>page\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">fill\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">'input[name=\"pass\"]'\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> password\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n    \u003Cspan class=\"token keyword\">await\u003C/span> \u003Cspan class=\"token keyword\">this\u003C/span>\u003Cspan class=\"token punctuation\">.\u003C/span>page\u003Cspan class=\"token punctuation\">.\u003C/span>\u003Cspan class=\"token function\">click\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token string\">'button[type=\"submit\"]'\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">;\u003C/span>\n  \u003Cspan class=\"token punctuation\">}\u003C/span>\n\u003Cspan class=\"token punctuation\">}\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>En BDD, ces objets de page sont appelés depuis des définitions de pas (steps) écrites en Gherkin.\nL’architecture doit rester simple : un dossier \u003Ccode>pages\u003C/code> pour les pages, un dossier \u003Ccode>steps\u003C/code> pour les\ndéfinitions et un dossier \u003Ccode>tests\u003C/code> pour les scénarios.\u003C/p>\n\u003Ch2 id=\"2-adopter-un-cadre-bdd\">2. Adopter un cadre BDD\u003C/h2>\n\u003Cp>La seconde étape consiste à adopter un \u003Cstrong>cadre comportemental\u003C/strong> tel que SpecFlow ou Cucumber. Le\nGherkin permet de décrire des comportements métiers compréhensibles par toutes les parties\nprenantes. Voici un exemple :\u003C/p>\n\u003Cpre class=\"language-gherkin\" data-language=\"gherkin\">\u003Ccode is:raw=\"\" class=\"language-gherkin\">\u003Cspan class=\"token feature\">\u003Cspan class=\"token keyword\">Fonctionnalité:\u003C/span>\u003Cspan class=\"token important\"> Authentification\u003C/span>\n  Afin de me connecter à mon compte\n  En tant qu’utilisateur enregistré\n  Je veux saisir mes identifiants et accéder à mon tableau de bord\n\u003C/span>\n  \u003Cspan class=\"token scenario\">\u003Cspan class=\"token keyword\">Scénario:\u003C/span>\u003Cspan class=\"token important\"> Connexion valide\u003C/span>\u003C/span>\n    \u003Cspan class=\"token atrule\">Étant donné\u003C/span> que je suis sur la page de connexion\n    \u003Cspan class=\"token atrule\">Quand\u003C/span> je saisis mon login et mon mot de passe valides\n    \u003Cspan class=\"token atrule\">Alors\u003C/span> je suis redirigé vers mon tableau de bord\n\u003C/code>\u003C/pre>\n\u003Cp>L’utilisation de BDD clarifie l’intention de vos tests et facilite leur revue. Les définitions de pas\ndoivent rester concises et déléguer les interactions aux objets de page.\u003C/p>\n\u003Ch2 id=\"3-modulariser-et-factoriser-les-composants\">3. Modulariser et factoriser les composants\u003C/h2>\n\u003Cp>Avec la croissance de votre suite, la tentation est grande de dupliquer du code. Au contraire,\nregroupez les interactions récurrentes dans des \u003Cstrong>helpers\u003C/strong> et centralisez la configuration.\nOrganisez votre dépôt avec soin : un fichier \u003Ccode>playwright.config.ts\u003C/code> unique, un dossier \u003Ccode>fixtures\u003C/code>\npour les données de test et un utilitaire pour l’injection des dépendances. Votre productivité\ns’en trouvera décuplée.\u003C/p>\n\u003Cpre class=\"language-plaintext\" data-language=\"plaintext\">\u003Ccode is:raw=\"\" class=\"language-plaintext\">// Exemple de configuration Playwright réutilisable\nexport default defineConfig({\n  use: {\n    headless: true,\n    viewport: { width: 1280, height: 720 },\n    actionTimeout: 10_000,\n    trace: 'retain-on-failure',\n  },\n});\n\u003C/code>\u003C/pre>\n\u003Ch2 id=\"4-intégrer-cicd-et-paralléliser\">4. Intégrer CI/CD et paralléliser\u003C/h2>\n\u003Cp>Une suite de tests n’a de valeur que si elle s’exécute régulièrement. Intégrez Playwright à votre\npipeline CI/CD (GitHub Actions, GitLab CI ou Azure DevOps) et profitez de la \u003Cstrong>parallélisation\u003C/strong>.\nDécoupez les suites en \u003Cstrong>shards\u003C/strong> pour répartir les tests sur plusieurs agents. Utilisez les\nannotations de saut (skip) pour isoler les scénarios instables et un rapporteur de flakiness pour\nles corriger.\u003C/p>\n\u003Cp>Dans GitHub Actions, une configuration simple peut lancer les tests sur deux containers :\u003C/p>\n\u003Cpre class=\"language-yaml\" data-language=\"yaml\">\u003Ccode is:raw=\"\" class=\"language-yaml\">\u003Cspan class=\"token key atrule\">jobs\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n  \u003Cspan class=\"token key atrule\">test\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n    \u003Cspan class=\"token key atrule\">runs-on\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> ubuntu\u003Cspan class=\"token punctuation\">-\u003C/span>latest\n    \u003Cspan class=\"token key atrule\">strategy\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n      \u003Cspan class=\"token key atrule\">matrix\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n        \u003Cspan class=\"token key atrule\">shard\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token number\">1\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\n    \u003Cspan class=\"token key atrule\">steps\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">uses\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> actions/checkout@v3\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">uses\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> actions/setup\u003Cspan class=\"token punctuation\">-\u003C/span>node@v4\n        \u003Cspan class=\"token key atrule\">with\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n          \u003Cspan class=\"token key atrule\">node-version\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> \u003Cspan class=\"token number\">18\u003C/span>\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">run\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> npm ci\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">run\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> npx playwright install\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">run\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> npx playwright test \u003Cspan class=\"token punctuation\">-\u003C/span>\u003Cspan class=\"token punctuation\">-\u003C/span>shard=$\u003Cspan class=\"token punctuation\">{\u003C/span>\u003Cspan class=\"token punctuation\">{\u003C/span> matrix.shard \u003Cspan class=\"token punctuation\">}\u003C/span>\u003Cspan class=\"token punctuation\">}\u003C/span>/2\n\u003C/code>\u003C/pre>\n\u003Ch2 id=\"5-maintenir-et-chasser-les-flakies\">5. Maintenir et chasser les flakies\u003C/h2>\n\u003Cp>Enfin, une suite robuste demande un \u003Cstrong>entretien régulier\u003C/strong>. Mettez en place des revues de tests,\nsurveillez les temps de réponse et identifiez les tests flakies. Des outils comme \u003Ca href=\"https://playwright.dev/docs/trace-viewer\">\u003Cstrong>Playwright\nTrace Viewer\u003C/strong>\u003C/a> et des dashboards Grafana aident à\ninvestiguer. En complément, introduisez des scripts de génération de données via des modèles\ngénératifs pour varier vos jeux de tests.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/placeholder_light_gray_block.png\" alt=\"Schéma d’architecture de test\">\u003C/p>\n\u003Cp>En suivant ces cinq étapes, vous poserez des fondations solides pour vos tests E2E. Une bonne\narchitecture se construit dans la durée : commencez petit, mesurez, itérez et impliquez vos équipes.\u003C/p>\n\u003Cp>Vous souhaitez aller plus loin ? N’hésitez pas à me contacter pour un audit personnalisé ou une\nsession de coaching.\u003C/p>",{"headings":22,"localImagePaths":39,"remoteImagePaths":40,"frontmatter":11,"imagePaths":41},[23,27,30,33,36],{"depth":24,"slug":25,"text":26},2,"1-choisir-la-bonne-architecture","1. Choisir la bonne architecture",{"depth":24,"slug":28,"text":29},"2-adopter-un-cadre-bdd","2. Adopter un cadre BDD",{"depth":24,"slug":31,"text":32},"3-modulariser-et-factoriser-les-composants","3. Modulariser et factoriser les composants",{"depth":24,"slug":34,"text":35},"4-intégrer-cicd-et-paralléliser","4. Intégrer CI/CD et paralléliser",{"depth":24,"slug":37,"text":38},"5-maintenir-et-chasser-les-flakies","5. Maintenir et chasser les flakies",[],[],[],"dompter-playwright.fr.md","reduction-temps-e2e",{"id":43,"data":45,"body":49,"filePath":50,"digest":51,"rendered":52,"legacyId":80},{"title":46,"description":47,"locale":14,"slug":43,"date":48},"Réduire votre temps d’exécution E2E sous 30 minutes : CI/CD, parallélisation et flake‑hunting","Optimisez vos tests end‑to‑end pour qu’ils s’exécutent en moins d’une demi‑heure grâce à des pipelines CI/CD performants, la parallélisation et la chasse aux tests instables.",["Date","2025-02-05T00:00:00.000Z"],"Les suites de tests end‑to‑end longues et instables sont le cauchemar des équipes de développement.\nLorsque l’exécution dépasse une heure, la boucle de feedback s’allonge et la tentation est grande de\npasser outre la validation. Pourtant, avec une démarche structurée, il est possible de ramener vos\ntests E2E sous la barre des 30 minutes sans sacrifier la couverture fonctionnelle. Cet article\ndécrit les leviers que j’ai mis en œuvre chez plusieurs clients pour accélérer les pipelines et\napporter plus de fiabilité.\n\n## 1. Mesurer et éliminer les lenteurs évidentes\n\nAvant d’optimiser, mesurez. Configurez des métriques de durée par test et par étape. Les outils\ncomme Playwright ou Cypress produisent des rapports détaillés. Analysez les 20 % de tests qui\nconsomment 80 % du temps. Souvent, des **attentes statiques** (`waitForTimeout(5000)`) ou des\nrequêtes réseau inutiles ralentissent la suite. Remplacez‑les par des attentes conditionnelles et\npréchargez les données via des API.\n\n## 2. Optimiser l’environnement d’exécution\n\nL’environnement compte autant que le code. Exécutez vos tests en mode **headless** avec une taille\nd’écran minimale. Utilisez des containers Docker légers et préinstallez les navigateurs. Dans un\npipeline CI/CD, évitez de reconstruire l’image à chaque run. Voici un exemple d’utilisation d’une\nimage Playwright prête à l’emploi :\n\n```yaml\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    container:\n      image: mcr.microsoft.com/playwright:focal\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm ci\n      - run: npx playwright install --with-deps\n      - run: npx playwright test --reporter=dot\n```\n\nLa mise en cache de `node_modules` et du navigateur réduit encore la durée des installations.\n\n## 3. Paralléliser et shard les suites\n\nLa parallélisation est le levier majeur pour réduire la durée. Playwright gère la **distribution des\ntests** sur plusieurs workers. Combinez cette capacité avec les matrices de votre runner pour\nexécuter des shards sur plusieurs agents. Par exemple, avec GitLab CI :\n\n```yaml\ne2e:\n  parallel:\n    matrix:\n      - SHARD_INDEX: 1\n      - SHARD_INDEX: 2\n  script:\n    - npx playwright test --shard=$SHARD_INDEX/2\n```\n\nVeillez à équilibrer les tests pour que chaque shard ait une durée similaire. Surveillez les temps\nd’exécution dans vos pipelines et ajustez le nombre de shards en fonction des ressources. Plus de\nworkers n’est pas toujours synonyme de performance : trop de concurrence peut saturer votre base de\ndonnées ou votre environnement d’intégration.\n\n## 4. Chasser les tests flakies\n\nLes flakies rallongent vos pipelines en générant des réexécutions. Pour les traquer, instrumentez\nvos tests avec des traces et enregistrez les erreurs. Playwright offre une commande pour relancer\nautomatiquement les tests instables :\n\n```json\n{\n  \"retries\": 2,\n  \"reporter\": \"html\"\n}\n```\n\nAnalysez ensuite les rapports pour identifier les scénarios qui échouent aléatoirement. La plupart du\ntemps, la cause est liée à des données partagées ou à des opérations asynchrones non maîtrisées.\nIsolez l’état de vos tests en utilisant des **fixtures** et nettoyez votre base de données entre\nchaque exécution.\n\n## 5. Adapter la granularité et la couverture\n\nPour atteindre un temps de run ambitieux, il faut parfois revoir la **granularité**. Concentrez les\nE2E sur les parcours critiques et déléguez le reste à des tests de services ou unitaires. Un ratio de\n70 % de tests de composants pour 30 % d’E2E offre un bon compromis. Documentez clairement cette\nstratégie pour que l’équipe sache quand ajouter un nouveau test E2E.\n\n## 6. Automatiser l’analyse et la visualisation\n\nLes pipelines rapides ne suffisent pas : il faut aussi comprendre les tendances. Intégrez des\ntableaux de bord (Grafana, Datadog) pour visualiser le temps moyen d’exécution, le taux de\nréussite et le nombre de tests flakies. Un exemple de requête Prometheus pourrait ressembler à :\n\n```promql\nsum(rate(playwright_tests_duration_seconds_sum[5m])) by (status)\n  /\nsum(rate(playwright_tests_duration_seconds_count[5m]))\n```\n\nEn affichant ces métriques, vous détecterez rapidement les régressions de performance et pourrez\nréagir avant que les tests ne deviennent un goulot d’étranglement.\n\n![Graphique de performance](/images/placeholder_light_gray_block.png)\n\n## Conclusion\n\nRéduire la durée de vos tests E2E sous 30 minutes n’est pas un simple exercice de configuration. Il\ns’agit d’une démarche globale qui touche à l’écriture des tests, à l’architecture de votre\napplication et à votre organisation. En combinant mesures précises, optimisation de l’environnement,\nparallélisation intelligente et chasse aux flakies, vous rendrez votre pipeline à la fois rapide et\nfiable. Et surtout, vous offrirez à vos équipes un feedback continu indispensable pour livrer du\nlogiciel de qualité.\n\nSi vous souhaitez être accompagné pour auditer et accélérer votre chaîne E2E, je me ferai un plaisir\nde vous aider.","src/content/blog/reduction-temps-e2e.fr.md","babd2e0fd61faa48",{"html":53,"metadata":54},"\u003Cp>Les suites de tests end‑to‑end longues et instables sont le cauchemar des équipes de développement.\nLorsque l’exécution dépasse une heure, la boucle de feedback s’allonge et la tentation est grande de\npasser outre la validation. Pourtant, avec une démarche structurée, il est possible de ramener vos\ntests E2E sous la barre des 30 minutes sans sacrifier la couverture fonctionnelle. Cet article\ndécrit les leviers que j’ai mis en œuvre chez plusieurs clients pour accélérer les pipelines et\napporter plus de fiabilité.\u003C/p>\n\u003Ch2 id=\"1-mesurer-et-éliminer-les-lenteurs-évidentes\">1. Mesurer et éliminer les lenteurs évidentes\u003C/h2>\n\u003Cp>Avant d’optimiser, mesurez. Configurez des métriques de durée par test et par étape. Les outils\ncomme Playwright ou Cypress produisent des rapports détaillés. Analysez les 20 % de tests qui\nconsomment 80 % du temps. Souvent, des \u003Cstrong>attentes statiques\u003C/strong> (\u003Ccode>waitForTimeout(5000)\u003C/code>) ou des\nrequêtes réseau inutiles ralentissent la suite. Remplacez‑les par des attentes conditionnelles et\npréchargez les données via des API.\u003C/p>\n\u003Ch2 id=\"2-optimiser-lenvironnement-dexécution\">2. Optimiser l’environnement d’exécution\u003C/h2>\n\u003Cp>L’environnement compte autant que le code. Exécutez vos tests en mode \u003Cstrong>headless\u003C/strong> avec une taille\nd’écran minimale. Utilisez des containers Docker légers et préinstallez les navigateurs. Dans un\npipeline CI/CD, évitez de reconstruire l’image à chaque run. Voici un exemple d’utilisation d’une\nimage Playwright prête à l’emploi :\u003C/p>\n\u003Cpre class=\"language-yaml\" data-language=\"yaml\">\u003Ccode is:raw=\"\" class=\"language-yaml\">\u003Cspan class=\"token key atrule\">jobs\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n  \u003Cspan class=\"token key atrule\">e2e\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n    \u003Cspan class=\"token key atrule\">runs-on\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> ubuntu\u003Cspan class=\"token punctuation\">-\u003C/span>latest\n    \u003Cspan class=\"token key atrule\">container\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n      \u003Cspan class=\"token key atrule\">image\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> mcr.microsoft.com/playwright\u003Cspan class=\"token punctuation\">:\u003C/span>focal\n    \u003Cspan class=\"token key atrule\">steps\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">uses\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> actions/checkout@v3\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">run\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> npm ci\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">run\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> npx playwright install \u003Cspan class=\"token punctuation\">-\u003C/span>\u003Cspan class=\"token punctuation\">-\u003C/span>with\u003Cspan class=\"token punctuation\">-\u003C/span>deps\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">run\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> npx playwright test \u003Cspan class=\"token punctuation\">-\u003C/span>\u003Cspan class=\"token punctuation\">-\u003C/span>reporter=dot\n\u003C/code>\u003C/pre>\n\u003Cp>La mise en cache de \u003Ccode>node_modules\u003C/code> et du navigateur réduit encore la durée des installations.\u003C/p>\n\u003Ch2 id=\"3-paralléliser-et-shard-les-suites\">3. Paralléliser et shard les suites\u003C/h2>\n\u003Cp>La parallélisation est le levier majeur pour réduire la durée. Playwright gère la \u003Cstrong>distribution des\ntests\u003C/strong> sur plusieurs workers. Combinez cette capacité avec les matrices de votre runner pour\nexécuter des shards sur plusieurs agents. Par exemple, avec GitLab CI :\u003C/p>\n\u003Cpre class=\"language-yaml\" data-language=\"yaml\">\u003Ccode is:raw=\"\" class=\"language-yaml\">\u003Cspan class=\"token key atrule\">e2e\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n  \u003Cspan class=\"token key atrule\">parallel\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n    \u003Cspan class=\"token key atrule\">matrix\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">SHARD_INDEX\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> \u003Cspan class=\"token number\">1\u003C/span>\n      \u003Cspan class=\"token punctuation\">-\u003C/span> \u003Cspan class=\"token key atrule\">SHARD_INDEX\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\n  \u003Cspan class=\"token key atrule\">script\u003C/span>\u003Cspan class=\"token punctuation\">:\u003C/span>\n    \u003Cspan class=\"token punctuation\">-\u003C/span> npx playwright test \u003Cspan class=\"token punctuation\">-\u003C/span>\u003Cspan class=\"token punctuation\">-\u003C/span>shard=$SHARD_INDEX/2\n\u003C/code>\u003C/pre>\n\u003Cp>Veillez à équilibrer les tests pour que chaque shard ait une durée similaire. Surveillez les temps\nd’exécution dans vos pipelines et ajustez le nombre de shards en fonction des ressources. Plus de\nworkers n’est pas toujours synonyme de performance : trop de concurrence peut saturer votre base de\ndonnées ou votre environnement d’intégration.\u003C/p>\n\u003Ch2 id=\"4-chasser-les-tests-flakies\">4. Chasser les tests flakies\u003C/h2>\n\u003Cp>Les flakies rallongent vos pipelines en générant des réexécutions. Pour les traquer, instrumentez\nvos tests avec des traces et enregistrez les erreurs. Playwright offre une commande pour relancer\nautomatiquement les tests instables :\u003C/p>\n\u003Cpre class=\"language-json\" data-language=\"json\">\u003Ccode is:raw=\"\" class=\"language-json\">\u003Cspan class=\"token punctuation\">{\u003C/span>\n  \u003Cspan class=\"token property\">\"retries\"\u003C/span>\u003Cspan class=\"token operator\">:\u003C/span> \u003Cspan class=\"token number\">2\u003C/span>\u003Cspan class=\"token punctuation\">,\u003C/span>\n  \u003Cspan class=\"token property\">\"reporter\"\u003C/span>\u003Cspan class=\"token operator\">:\u003C/span> \u003Cspan class=\"token string\">\"html\"\u003C/span>\n\u003Cspan class=\"token punctuation\">}\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>Analysez ensuite les rapports pour identifier les scénarios qui échouent aléatoirement. La plupart du\ntemps, la cause est liée à des données partagées ou à des opérations asynchrones non maîtrisées.\nIsolez l’état de vos tests en utilisant des \u003Cstrong>fixtures\u003C/strong> et nettoyez votre base de données entre\nchaque exécution.\u003C/p>\n\u003Ch2 id=\"5-adapter-la-granularité-et-la-couverture\">5. Adapter la granularité et la couverture\u003C/h2>\n\u003Cp>Pour atteindre un temps de run ambitieux, il faut parfois revoir la \u003Cstrong>granularité\u003C/strong>. Concentrez les\nE2E sur les parcours critiques et déléguez le reste à des tests de services ou unitaires. Un ratio de\n70 % de tests de composants pour 30 % d’E2E offre un bon compromis. Documentez clairement cette\nstratégie pour que l’équipe sache quand ajouter un nouveau test E2E.\u003C/p>\n\u003Ch2 id=\"6-automatiser-lanalyse-et-la-visualisation\">6. Automatiser l’analyse et la visualisation\u003C/h2>\n\u003Cp>Les pipelines rapides ne suffisent pas : il faut aussi comprendre les tendances. Intégrez des\ntableaux de bord (Grafana, Datadog) pour visualiser le temps moyen d’exécution, le taux de\nréussite et le nombre de tests flakies. Un exemple de requête Prometheus pourrait ressembler à :\u003C/p>\n\u003Cpre class=\"language-promql\" data-language=\"promql\">\u003Ccode is:raw=\"\" class=\"language-promql\">\u003Cspan class=\"token keyword\">sum\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token function\">rate\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>playwright_tests_duration_seconds_sum\u003Cspan class=\"token context-range\">\u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token range-duration number\">5m\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span> \u003Cspan class=\"token keyword\">by\u003C/span> \u003Cspan class=\"token vector-match\">\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token label-key attr-name\">status\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003C/span>\n  \u003Cspan class=\"token operator\">/\u003C/span>\n\u003Cspan class=\"token keyword\">sum\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>\u003Cspan class=\"token function\">rate\u003C/span>\u003Cspan class=\"token punctuation\">(\u003C/span>playwright_tests_duration_seconds_count\u003Cspan class=\"token context-range\">\u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token range-duration number\">5m\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\u003Cspan class=\"token punctuation\">)\u003C/span>\n\u003C/code>\u003C/pre>\n\u003Cp>En affichant ces métriques, vous détecterez rapidement les régressions de performance et pourrez\nréagir avant que les tests ne deviennent un goulot d’étranglement.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/placeholder_light_gray_block.png\" alt=\"Graphique de performance\">\u003C/p>\n\u003Ch2 id=\"conclusion\">Conclusion\u003C/h2>\n\u003Cp>Réduire la durée de vos tests E2E sous 30 minutes n’est pas un simple exercice de configuration. Il\ns’agit d’une démarche globale qui touche à l’écriture des tests, à l’architecture de votre\napplication et à votre organisation. En combinant mesures précises, optimisation de l’environnement,\nparallélisation intelligente et chasse aux flakies, vous rendrez votre pipeline à la fois rapide et\nfiable. Et surtout, vous offrirez à vos équipes un feedback continu indispensable pour livrer du\nlogiciel de qualité.\u003C/p>\n\u003Cp>Si vous souhaitez être accompagné pour auditer et accélérer votre chaîne E2E, je me ferai un plaisir\nde vous aider.\u003C/p>",{"headings":55,"localImagePaths":77,"remoteImagePaths":78,"frontmatter":45,"imagePaths":79},[56,59,62,65,68,71,74],{"depth":24,"slug":57,"text":58},"1-mesurer-et-éliminer-les-lenteurs-évidentes","1. Mesurer et éliminer les lenteurs évidentes",{"depth":24,"slug":60,"text":61},"2-optimiser-lenvironnement-dexécution","2. Optimiser l’environnement d’exécution",{"depth":24,"slug":63,"text":64},"3-paralléliser-et-shard-les-suites","3. Paralléliser et shard les suites",{"depth":24,"slug":66,"text":67},"4-chasser-les-tests-flakies","4. Chasser les tests flakies",{"depth":24,"slug":69,"text":70},"5-adapter-la-granularité-et-la-couverture","5. Adapter la granularité et la couverture",{"depth":24,"slug":72,"text":73},"6-automatiser-lanalyse-et-la-visualisation","6. Automatiser l’analyse et la visualisation",{"depth":24,"slug":75,"text":76},"conclusion","Conclusion",[],[],[],"reduction-temps-e2e.fr.md"]